/* **********************************************************
 * Copyright (c) 2017-2020 Google, Inc.  All rights reserved.
 * **********************************************************/

/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Google, Inc. nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL VMWARE, INC. OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

/* This trace analyzer requires access to the modules.log file and the
 * libraries and binary from the traced execution in order to obtain further
 * information about each instruction than was stored in the trace.
 * It does not support online use, only offline.
 */
#define SHARE_MEM
//#define SHARE_MEM_THIS
#define TO_FILE

#include "dr_api.h"
#include "opcode_mix.h"
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <vector>
#include <string.h>

#ifndef SHARE_MEM_THIS

#include <stdio.h>
#include <stdlib.h>
#include <ctime>
#endif

#ifdef SHARE_MEM_THIS
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <assert.h>
#include <thread>
#include <mutex>
#include <ctime>
std::mutex mtx;
/** share memory head struct, used for judging the rd_idx of buffer block  */
typedef struct shm_head
{
    int rd_idx;
    int wr_idx;
    int blocks;
    int blksz;
    int signal;
    int connect;
}head_t;
 
typedef struct shmfifo
{
    head_t *p_head;
    int *flags;
    char *p_payload;
    int shmid;
}shmfifo_t;

typedef struct interbuf{
    unsigned long pc;
    unsigned char instr[8];
}interbuf;

shmfifo_t *fifo;

shmfifo_t* shmfifo_init(int key,int blocks,int blksz){

    shmfifo_t *p=(shmfifo_t*)malloc(sizeof(shmfifo_t));
    assert(p);
    head_t *h = (head_t*)malloc(sizeof(head_t));
    assert(h);
    int * fs = (int *)malloc(sizeof(int)*blocks);
    int len = (blocks+1)*sizeof(int)+blocks * blksz + sizeof(head_t);

    int shmid = shmget(key, len, 0);

    printf("userinput parm:-------------\nkey ==== %d\nblocks === %d\nblksz ===%d\nlen ====%d\nshmid ===%d\n-----------------------------------\n",key,blocks,blksz,len,shmid);

    if(shmid == -1)
    {
        shmid = shmget(key, len, IPC_CREAT|0666);
        printf("sucess create shmid === %d\n",shmid);
      //  shmfifo *p_share = (shmfifo_t *)shmat(shmid,NULL,0);
        /**head need malloc at shared memory */
        head_t *h_share = (head_t *)shmat(shmid,NULL,0);
        int * fs_share = (int *) ((unsigned long)h_share + sizeof(head_t));
     //  head_t *h_share = (head_t *) (p_share + sizeof(head_t));
        if(shmid == -1)
        {
            perror("shmget failure\n");
            exit(1);
        }
        else
        {
            // initialization
            printf("begin init!!\n");
            h->rd_idx=0;
            h->wr_idx=0;
            h->blocks=blocks;
            h->blksz=blksz;
            for(int i =0; i< blocks; i++){
                fs[i] = 0;
            }
            memcpy(h_share, h, sizeof(head_t));
            memcpy(fs_share, fs, sizeof(int)*blocks);
            p->p_head=h_share;
            p->flags = fs_share;
            p->p_payload=(char*)((unsigned long)p->p_head+ sizeof(head_t) + sizeof(int)*blocks);
            p->shmid=shmid;
            p->p_head->signal=0;
            p->p_head->connect = 1;

            printf("put.c init p->p_head->rd_idx===%d\n",p->p_head->rd_idx);
            printf("put.c init p->p_head->wr_idx===%d\n",p->p_head->wr_idx);
            printf("put.c init p->p_head->blocks===%d\n",p->p_head->blocks);
            printf("put.c init p->p_head->blksz===%d\n",p->p_head->blksz);
            printf("put.c init p->head===%p\n",p->p_head);
            printf("put.c init p->shmid===%d\n",p->shmid);
            printf("put.c init p->p_head->signal===%d\n",p->p_head->signal);

            printf("finish init!!\n");


        }
        //memcpy(p_share, p, sizeof(shmfifo_t));
    }
    else
    {
        printf("begin get!!");
        printf("get shmid === %d\n",shmid);

        //h=(head_t*)shmat(shmid,NULL,0);
        //p->p_head=h;
        p->p_head=(head_t*)shmat(shmid,NULL,0);
        p->flags = (int *)((unsigned long)p->p_head + sizeof(head_t));
        p->p_payload=(char*)((unsigned long)p->p_head+ sizeof(head_t) + sizeof(int)*blocks);
        p->shmid = shmid;
        if (p->p_head == (void*)-1){
                perror("shmat");
                exit(1);
        }
        p->p_head->connect = 1;
        printf("get sucess = shimd:%d\n",p->shmid);
        printf("get sucess = p->p_head:%p\n",p->p_head);
        printf("get sucess = p->p_head->blksz:%d\n",p->p_head->blksz);
        printf("get sucess = p->p_head->rd_idx:%d\n",p->p_head->rd_idx);
        printf("get sucess = p->p_head->wr_idx:%d\n",p->p_head->wr_idx);
        printf("get sucess = p->p_head->blocks:%d\n",p->p_head->blocks);
        printf("get sucess = p->p_head->signal:%d\n",p->p_head->signal);


    }
    return p;
}
void shmfifo_get(shmfifo_t* fifo, void* buf)
{
    while(1){
    if(fifo->flags[fifo->p_head->rd_idx]==1){
        memcpy(buf,fifo->p_payload+(fifo->p_head->rd_idx*fifo->p_head->blksz),fifo->p_head->blksz);

        fifo->flags[fifo->p_head->rd_idx] = 0;
        fifo->p_head->rd_idx=(fifo->p_head->rd_idx+1)%(fifo->p_head->blocks);
        return;
    }
    }

}


void shmfifo_destroy(shmfifo_t* fifo)
{

    shmdt(fifo->p_head);

    shmctl(fifo->shmid, IPC_RMID, 0);
    free(fifo);

}

#endif
const std::string opcode_mix_t::TOOL_NAME = "Opcode mix tool";

analysis_tool_t *
opcode_mix_tool_create(const std::string &module_file_path, unsigned int verbose,
                       const std::string &alt_module_dir)
{
    return new opcode_mix_t(module_file_path, verbose, alt_module_dir);
}

opcode_mix_t::opcode_mix_t(const std::string &module_file_path, unsigned int verbose,
                           const std::string &alt_module_dir)
    : module_file_path_(module_file_path)
    , knob_verbose_(verbose)
    , knob_alt_module_dir_(alt_module_dir)
{
}

std::string
opcode_mix_t::initialize()
{
    serial_shard_.worker = &serial_worker_;
    if (module_file_path_.empty())
        return "Module file path is missing";
    dcontext_.dcontext = dr_standalone_init();
    std::string error = directory_.initialize_module_file(module_file_path_);
    if (!error.empty())
        return "Failed to initialize directory: " + error;
    module_mapper_ =
        module_mapper_t::create(directory_.modfile_bytes_, nullptr, nullptr, nullptr,
                                nullptr, knob_verbose_, knob_alt_module_dir_);
    module_mapper_->get_loaded_modules();
    error = module_mapper_->get_last_error();
    if (!error.empty())
        return "Failed to load binaries: " + error;
    return "";
}

opcode_mix_t::~opcode_mix_t()
{
    for (auto &iter : shard_map_) {
        delete iter.second;
    }
}

bool
opcode_mix_t::parallel_shard_supported()
{
    return true;
}

void *
opcode_mix_t::parallel_worker_init(int worker_index)
{
    auto worker = new worker_data_t;
    return reinterpret_cast<void *>(worker);
}

std::string
opcode_mix_t::parallel_worker_exit(void *worker_data)
{
    worker_data_t *worker = reinterpret_cast<worker_data_t *>(worker_data);
    delete worker;
    return "";
}

void *
opcode_mix_t::parallel_shard_init(int shard_index, void *worker_data)
{
#ifdef SHARE_MEM_THIS 
    key_t key;
    char pathname[30];
    strcpy(pathname, "/home/duan/fok.key");
    key = ftok(pathname,0x03);
    if(key == -1){
        perror("ftok error");
        exit(1);
    }   
    fifo = shmfifo_init(key, 30 , sizeof(interbuf));
#endif
    worker_data_t *worker = reinterpret_cast<worker_data_t *>(worker_data);
    auto shard = new shard_data_t(worker);
    std::lock_guard<std::mutex> guard(shard_map_mutex_);
    shard_map_[shard_index] = shard;
    return reinterpret_cast<void *>(shard);
}

bool
opcode_mix_t::parallel_shard_exit(void *shard_data)
{
    // Nothing (we read the shard data in print_results).
    return true;
}

bool
opcode_mix_t::parallel_shard_memref(void *shard_data, const memref_t &memref)
{
    shard_data_t *shard = reinterpret_cast<shard_data_t *>(shard_data);
    /**
    if (memref.marker.type == TRACE_TYPE_MARKER &&
        memref.marker.marker_type == TRACE_MARKER_TYPE_FILETYPE) {
        if (TESTANY(OFFLINE_FILE_TYPE_ARCH_ALL, memref.marker.marker_value) &&
            !TESTANY(build_target_arch_type(), memref.marker.marker_value)) {
            shard->error = std::string("Architecture mismatch: trace recorded on ") +
                trace_arch_string(static_cast<offline_file_type_t>(
                    memref.marker.marker_value)) +
                " but tool built for " + trace_arch_string(build_target_arch_type());
            return false;
        }
    }*/
    if (!type_is_instr(memref.instr.type) &&
        memref.data.type != TRACE_TYPE_INSTR_NO_FETCH) {
        return true;
    }
    ++shard->instr_count;

    app_pc mapped_pc;
    
    const app_pc trace_pc = reinterpret_cast<app_pc>(memref.instr.addr);
#ifdef SHARE_MEM
    mapped_pc = trace_pc;
#else    
    if (trace_pc >= shard->last_trace_module_start &&
        static_cast<size_t>(trace_pc - shard->last_trace_module_start) <
            shard->last_trace_module_size) {
        mapped_pc =
            shard->last_mapped_module_start + (trace_pc - shard->last_trace_module_start);
    } else {
        std::lock_guard<std::mutex> guard(mapper_mutex_);
        mapped_pc = module_mapper_->find_mapped_trace_bounds(
            trace_pc, &shard->last_mapped_module_start, &shard->last_trace_module_size);
        if (!module_mapper_->get_last_error().empty()) {
            shard->last_trace_module_start = nullptr;
            shard->last_trace_module_size = 0;
            shard->error = "Failed to find mapped address for " +
                to_hex_string(memref.instr.addr) + ": " +
                module_mapper_->get_last_error();
            return false;
        }
        shard->last_trace_module_start =
            trace_pc - (mapped_pc - shard->last_mapped_module_start);
    }
#endif
#ifdef SHARE_MEM_THIS
   /** key_t key;
    char pathname[30];
    strcpy(pathname, "/home/duan/fok.key");
    key = ftok(pathname,0x03);
    if(key == -1){
        perror("ftok error");
        exit(1);
    }   
    shmfifo_t *fifo = shmfifo_init(key, 3 , sizeof(interbuf));*/
    interbuf buf;
     
    printf("in thread get sucess = fifo->p_head->rd_idx:%d\n",fifo->p_head->rd_idx);
   // long start = time(0);
    while(1){
    mtx.lock(); 
    if(fifo->flags[fifo->p_head->rd_idx]==1){ 
       
        memcpy(&buf,(int *)((unsigned long)fifo->p_payload+(fifo->p_head->rd_idx*fifo->p_head->blksz)),fifo->p_head->blksz);

        fifo->flags[fifo->p_head->rd_idx] = 0;
    
        printf("get sucess = fifo->p_head->rd_idx:%d\n",fifo->p_head->rd_idx);
        printf("get sucess = fifo->p_head->wr_idx:%d\n",fifo->p_head->wr_idx);
        printf("get sucess = fifo->flags[0]:%d\n",fifo->flags[0]);
        printf("get sucess = fifo->flags[1]:%d\n",fifo->flags[1]);
        printf("get sucess = fifo->flags[2]:%d\n",fifo->flags[2]);
//        sleep(1);
        fifo->p_head->rd_idx=(fifo->p_head->rd_idx+1)%(fifo->p_head->blocks);
        mtx.unlock();
        break;
    }
    mtx.unlock();
    //long end = time(0);
   // if(end - start >60) return false;
    if(fifo->p_head->signal ==1) {
       
       printf("receive siganl  \n");
       return false;
    
    }
    }
    //int id = shmget(1234,8 ,0);
    //shmfifo_get(fifo, &p);
   // interbuf * p = (interbuf * ) shmat(id, NULL, 0);
    
    printf("success! pc = %016lx \n", buf.pc);
//   trace_pc =(app_pc)p->pc;
    mapped_pc =(byte *)buf.instr;
  //  printf("success! instr = %02x  %02x\n", buf.instr[0],buf.instr[1]);
    //sleep(2);
#endif 
    int opcode;
    int a = 1;
    auto cached_opcode = shard->worker->opcode_cache.find(mapped_pc);
   // if (a == 0) {
    if (a==0 && cached_opcode != shard->worker->opcode_cache.end()) {
        opcode = cached_opcode->second;
        printf(" opcode find      \n");
        //std::cerr << "in if branch   ..........................................\n"<<std::endl;
    } else {
        instr_t instr;
        instr_init(dcontext_.dcontext, &instr);
        printf(" before decode      \n");
        app_pc next_pc = decode(dcontext_.dcontext, mapped_pc, &instr);
        if (next_pc == NULL || !instr_valid(&instr)) {
            shard->error =
                "Failed to decode instruction " + to_hex_string(memref.instr.addr);
            return false;
        }
        opcode = instr_get_opcode(&instr);
        shard->worker->opcode_cache[mapped_pc] = opcode;
        instr_free(dcontext_.dcontext, &instr);
    }
    ++shard->opcode_counts[opcode];
    return true;
}

std::string
opcode_mix_t::parallel_shard_error(void *shard_data)
{
    shard_data_t *shard = reinterpret_cast<shard_data_t *>(shard_data);
    return shard->error;
}

bool
opcode_mix_t::process_memref(const memref_t &memref)
{
    if (!parallel_shard_memref(reinterpret_cast<void *>(&serial_shard_), memref)) {
        error_string_ = serial_shard_.error;
        return false;
    }
    return true;
}

static bool
cmp_val(const std::pair<int, int_least64_t> &l, const std::pair<int, int_least64_t> &r)
{
    return (l.second > r.second);
}

bool
opcode_mix_t::print_results()
{
    shard_data_t total(0);
    if (shard_map_.empty()) {
        total = serial_shard_;
    } else {
        for (const auto &shard : shard_map_) {
            total.instr_count += shard.second->instr_count;
            for (const auto &keyvals : shard.second->opcode_counts) {
                total.opcode_counts[keyvals.first] += keyvals.second;
            }
        }
    }
#ifdef TO_FILE
    time_t now = time(0);
    tm *ltm = localtime(&now);
    std::string  outname = "/home/duan/result" + std::to_string(ltm->tm_mday)+std::to_string(ltm->tm_hour)+std::to_string(ltm->tm_min)+std::to_string(ltm->tm_sec) + ".txt" ;
       
    FILE *outfile = fopen(outname.c_str(),"w" );
    if(outfile == NULL) exit(1);
    fprintf(outfile, "%s results: \n", TOOL_NAME.c_str() );
    fprintf(outfile, "               %ld: total executed instructions \n", total.instr_count );
    std::vector<std::pair<int, int_least64_t>> sorted(total.opcode_counts.begin(),
                                                      total.opcode_counts.end());
    std::sort(sorted.begin(), sorted.end(), cmp_val);
    for (const auto &keyvals : sorted) {
        fprintf(outfile, "               %ld:          %s \n", keyvals.second, decode_opcode_name(keyvals.first) );    
    }
    fclose(outfile);
  
#else   
    std::cerr << TOOL_NAME << " results:\n";
    std::cerr << std::setw(15) << total.instr_count << " : total executed instructions\n";
    std::vector<std::pair<int, int_least64_t>> sorted(total.opcode_counts.begin(),
                                                      total.opcode_counts.end());
    std::sort(sorted.begin(), sorted.end(), cmp_val);
    for (const auto &keyvals : sorted) {
        std::cerr << std::setw(15) << keyvals.second << " : " << std::setw(9)
                  << decode_opcode_name(keyvals.first) << "\n";
    }
#endif
    return true;
}
